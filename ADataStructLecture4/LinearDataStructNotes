
public class LinearDataStructNotes {
	/**NOTE: If asked 'what type of data structure will you use?' in an interview; NEVER say Array, say Linked Lists!!!*/

	/*
	 * Arrays
	 * ArrayLists
	 * Linked Lists						**Answer will be Linked Lists (Important)
	 * 		* Single Linked Lists
	 * 		* Double Linked Lists
	 * Stacks
	 * Queues
	 * 
	 */
	
	/*		Arrays
	 * 			*Fixed-size sequential collection of elements of same type
	 * 		
	 * 0	1	2	3	4	5	6	7	8	9		(Indices)	array length = 10
	 * []	[]	[]	[]	[]	[]	[]	[]	[*]	[]
	 * 	|								|
	 * 	|							9th element
	 * 	NOTE: We don't know the address of this initial index (0)
	 * 		Compute Address of the array:
	 * 			Initial Address + (Index of element * byte size of element)		//Byte size of int is 4 (4 bytes = (8 * 4 bits))
	 * 				|
	 * 			2204255 (all the memory is byte participle)
	 * 
	 *			//Calculate the 5th element:
	 *				2204255 + (5 * 4)
	 * 	
	 * 
	 * 	Array size is fixed at the time of array's construction
	 * 	array elements are placed contiguously in memory				***Contiguous: Share a common border
	 * 	indexing into a component takes O(1) time
	 * 
	 * Java arrays are homogeneous
	 * 		-All components are of same type (object or primitive)
	 * 		-Array of object type can contain objects of any respective subtype
	 * An array itself is an object
	 * 		-Is allocated dynamically by means of new
	 * 		-Is automatically deallocated when no longer referrred to
	 * When array is first created, all values are automatically initialized with:
	 * 		* 0 for array int[] or double[]
	 * 		* false for boolean[] 
	 * 		* null for array of objects (String, Circle, etc.)
	 * 
	 * 
	 * Limitations of Arrays:
	 * 		-Static data structure
	 * 		-Insertion/deletion in an array is time consuming:
	 * 			It will be O(n) (worst-case time complexity; and n represents array size)
	 * 
	 * 			Insert an entry e in index 3	**Will shift the elements to the right
	 * 		[a]	[b]	[c]	[d]	[f]	[g]	[h]	[]	[]	[]
	 * 					->	->	->	->	->
	 * 
	 * 			After:							**Shifting will have Time Complexity of O(n)
	 * 		[a]	[b]	[e]	[c]	[d]	[f]	[g]	[h]	[]	[]
	 * 
	 * 			Deleting element at index 3 		**Will sift elements to the left (can go the other way around), 
	 * 		[a]	[b]	[e]	[c]	[d]	[f]	[g]	[h]	[]	[]		and put a null value on index 7 (nullify index 7), otherwise, you will
	 * 													get a copied index
	 * 			After
	 * 		[a]	[b]	[c]	[d]	[f]	[g]	[h]	[null]	[] []
	 */
	
	/*	ArrayLists		(Object-Oriented programming)
	 * 		*Dynamic sized arrays in Java that implements List interface
	 * 			-Not static sized (static size is arrays)
	 * 	ArrayList {
	 * 		size();
	 * 		isEmpty();
	 * 		add(int i, E e);		//If not specify the index, will add the element at the end
	 * 		get(int i);
	 * 		remove(int i);			//Move every other element after specified index to the left and nullify the end
	 * 		set(int i, E e);
	 * }
	 * 
	 * 		In the array based implementation
	 * 			* The space used by data structure is O(n)
	 * 			* size, isEmpty, get, and set run in O(1) time
	 * 			* add and remove run in O(n) time as these two operations need to
	 * 					 shift forward and backward on the array, respectively
	 * 
	 * 
	 * 		When array is full, instead of throwing an exception, replace the array with a larger one
	 * 			*EX:
	 * 				arr[5]
	 * 			
	 * 				[J]	[M]	[O]	*This is a size 3 array (initial array is static in size)
	 * 					//Want to add two more elements P and R
	 * 				[J]	[M]	[O]	[P]	[R]		*Create a new array of greater size in order to include the extra elements
	 * 					//There can be more students to be put in the array; do the same thing again	 * 				
	 * 				[J]	[M]	[O]	[P]	[R]		N1 N2 N3
	 * 
	 * 		//**For example: When 30 students already occupy the limit N = 30 size of classroom, increase the size by 
	 * 			creating a new array of greater size
	 * 		
	 * 		Algorithm - add(element)
	 * 			newArray = new array of size newN	*newArray has size newN (which is > N)
	 * 			if n = N then:						*Check if the initial array size reaches the capacity of N
	 * 				for i = 0 to N - 1 do:			*The for loop will copy every element in the original array
	 * 					newArray[i] = array[i]
	 * 				array = newArray
	 * 				n = n + 1						*increase the size of the new array (Can optimize the code by omitting this line)
	 * 				array[n] = element				*Add the newest element at the newest point
	 * 
	 * 			NOTE: for optimizing, omit the line n = n + 1, and change the next line:
	 * 				array[n++] = element
	 * 
	 * 			*Incremental strategy: Increase size by a constant C (Ex:)
	 * 			*Doubling strategy: Double the size
	 * 			
	 * 
	 * 		Incremental Strategy analysis
	 * 			[n]	==	[N]		[]						*Ceil will round ratios up
	 * 			[0]		[0]		[]
	 * 			[1]		[c]		[Extend array]				Replace the array k = ceil(n/c) times
	 * 			[2]		[c]		[]							The total time T(n) is proportional to:
	 * 			[...]	[...]	[]						n + c + 2c + 3c + 4c +...+kc = n + ck(k+1)/2
	 * 			[c]		[c]		[]						
	 * 			[c + 1]	[2c]	[Extend array]			Since c is constant
	 *			[...]	[...]	[]							T(n) is O(n + k^2), i.e, O(n^2)
	 * 			[2c]	[2c]	[]
	 * 			[2c + 1][3c]	[Extend array]			The amortized time of an add(element) operation is O(n)
	 * 			[...]	[...]	[]
	 * 			[n]		[kc]	[k = ceil(n/c)]
	 * 
	 * 
	 * 		Doubling Strategy analysis (Probably best one to use)
	 * 			[n]	==	[N]		[]						*Ceil will round ratios up
	 * 			[0]		[0]		[]
	 * 			[1]		[1]		[Extend array]				Replace the array k = ceil(n/c) times
	 * 			[2]		[2]		[Extend array]				The total time T(n) is proportional to:
	 * 			[3]		[4]		[Extend array]			n + 1 + 2 + 4 + 8 +...+2^k = n + 2^(k+1) - 1 <= 5n
	 * 			[4]		[4]		[]						
	 * 			[5]		[8]		[Extend array]			Since c is constant
	 *			[6]		[8]		[]							T(n) is O(n)
	 * 			[7]		[8]		[]						The amortized time of an add(element) operation is O(1)
	 * 			[...]	[...]	[]
	 * 			[n]		[kc]	[k = ceil(log(n))]
	 * 
	 * 
	 * 	* Whichever strategy is better, depends entirely on the size of the Array!
	 * 			-Sometimes Increment strategy is better if there are only a few elements to add
	 * 			-Double strategy is good for many elements 	 * 
	 */
	
	/*
	 * 	Linked Lists
	 * 		* A concrete data structure  consisting of a sequence of nodes		**Instead of treating each point in the array as an
	 * 																			element; treat each as a node
	 * 		* Each node stores
	 * 			- Element (each element stores an address)
	 * 			- link to the next/previous node			***Can change links depending on where the new node will be put
	 */
	 /** 
	 * 	 head/first				tail/last
	 * 		  |						|
	 * 		[e_1][*]---->[e_2][]----->[e_3][*]----->[X]							Singly Linked list (Move only one direction)
	 * 
	 * 	 header															trailer
	 * 		|															  |
	 * 		[X]<---->[*][e_1][*]<---->[*][e_2][*]<---->[*][e_3][*]<----->[X]	Doubly linked list (Move in both directions)
	 * 
	 * 			Notation
	 * 					([*]------>)	Connectors
	 * 
	 * 		NOTE:
	 * 			*In a singly linked list, a head is the first node
	 * 				-When implementing a new node within two nodes, the new node must extend to the next node, and the prev node
	 * 					has to extend to the new node:
	 * 
	 * 				put:	[e_A] between [e_1] and [e_2]
	 * 
	 * 					[e_1][*]---->[e_2][]----->[e_3][*]----->[X]
	 * 								  |
	 * 							[e_A][*]
	 * 
	 * 			*In a doubly linked list, both header and trailer are place-holders
	 * 				-The header is null node (contains no element and no address) 
	 * 					that points to the first element
	 * 				-The trailer is a null node
	 * 
	 * 		Node Class
	 * 			private static class Node<E>{		//E is the Data Type
	 * 				private E element;
	 * 				private Node<E> next;
	 * 				//private Node<E> prev	//commented out because
	 * 				public Node(E e, Node<E> n){
	 * 					element = e;
	 * 					next = n;
	 * 					//prev = p
	 * 				}
	 * 				public E getElement() { return element;}
	 * 				public Node<E> getNext() { return next;}
	 * 				//public Node<E> getPrev() { return prev;}
	 * 				public void setNext(Node<E> n) { next = n;}
	 * 				//public void setPrev(Node<E> p) { prev = p;}
	 * 			}
	 * 
	 * 		Singly linked list: ADT					(Abstract Data Type)
	 * 			private Node<E> head = null;
	 * 			private Node<E> head = null;
	 * 			//	Number of nodes in the list
	 * 			private int size = 0;
	 * 
	 * 			public int size()
	 * 			public boolean isEmpty()
	 * 			public E first()
	 * 			public E last()
	 * 			public void addFirst(E e)
	 * 			public void addLast(E e)
	 * 			public E removeFirst()
	 *  
	 * 
	 * 			Singly Linked Lists: addFirst(E e)
	 * 
	 * 					 head						tail
	 * 					  |							  |
	 * 					[e_1][*]---->[e_2][]----->[e_3][*]----->[X]
	 * 			public void addFirst (E e) {
	 * 				head = new Node<>(e , head );			//**Assign head to head, because it will be the next node
	 * 				if(size == 0)
	 * 					tail = head;						//**When there is no node in the next node, the next node will be head***
	 * 				size++									//		When there is no node in prev node, prev node will be head
	 * 			} 
	 * 
	 * 			Singly Linked Lists: removeFirst()
	 * 
	 * 								head		tail
	 * 					  			  |			  | 
	 * 					[e_1][]		[e_2][]----->[e_3][*]----->[X]
	 * 			public void removeFirst () {
	 * 				if(isEmpty()) return null;
	 * 				E answer = head.getElement();
	 * 				head = head.getNext();
	 * 				size--;
	 * 				if(size == 0)
	 * 					tail = null;
	 * 				return answer;
	 * 			} 
	 * 
	 */
	
	public static void main(String[] args) {
		
		long start = System.currentTimeMillis();
		System.out.printf("Incremental Strategy%n");
		int[] arr = new int[4];
		int[] newArr = add(2, arr, 4); newArr = add(3, arr, 4); newArr = add(6, arr, 4); newArr = add(1, arr, 4);
		newArr = add(5, arr, 4);
		for(int i : newArr) {
			System.out.printf("%d ", i);
		}
		long end = System.currentTimeMillis();
		System.out.printf("%nTotal Time: %d", (end - start));
	}
	
	//Incremental Strategy
	public static int[] add(int element, int[] array, int N) {
		//Use the Math.ceil function to round up the 
		
		int[] newArr;
		int count = 0;
		for(int i : array)
			count += (i == 0)? 0 : 1;
		
		if((count) == N) {
			newArr = new int[array.length + 1];
			
			for(int i = 0; i < array.length; i++) {
				newArr[i] = array[i];
			}
			newArr[newArr.length - 1] = element;
			
			//Return new array of new size
		}else {
			//If the size of the array doesn't exceed the limit, then place the newest number at the top of the list
			//newArr = new int[array.length];
			newArr = array;
			for(int i = 0; i < array.length; i++) {
				if (array[i] == 0) {
					newArr[i] = element;
					break;
				}
			}
		}
		return newArr;		
	}	

}
