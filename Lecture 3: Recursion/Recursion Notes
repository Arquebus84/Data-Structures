
public class RecursionNote {

	/**
	 * Recursion requires:
	 * 		Base case
	 * 		Recursive function Terminate at 0 (i.e. the recursive case must converge to zero (recursiveFunc(n - 1)))
	 * 
	 */
	
	public static void main(String[] args) {
		
		int num = 3;
		int pow = 2;
		System.out.println(num + "! = " + recFactorial(num));
		System.out.println(num + "^" + pow + " = " + recPower(num, pow));
		System.out.println(num + "^" + pow + " = " + fasterRecPower(num, pow));

	}
	
	//Linear Recursion
	
	//Factorial n! = 1 * 2 * 3 * ... (n - 1) * n
	/*
	 * f(n) = {1, 				n = 0}
	 * 		  {n * f(n - 1),	n > 0}
	 */
	public static int recFactorial(int n) {		//Entire function is called n + 1 times
		if(n == 0) {		// Optimization: n == 1 return 1;
			//Base case
			return 1;						// 1 operation
		}else {
			//Recursive case
			return n * recFactorial(n - 1);	// n operations
		}
		
		//Order of n + 1, n + 1 is O(n)
		//Running time is O(n)
		
	}
	//Power function
	/*
	 * 	p(x, n) = x^n
	 * 
	 * 	= {1,					n = 0}
	 * 	  {x * p(x, n - 1)		n > 0}
	 */
	public static double recPower(double x, int n) {
		if(n == 0) {
			//Base case
			return 1;							// 1 Operation
		}else {
			//Recursive case
			return x * recPower(x, n - 1);		// n operations
		}
		
		//Order of n + 1
		//Running time?		will be O(n)
		//What can we do better? could be log(n) or sqrt(n)			(Recall that it is log_2(n), sub 2**)
	}
	
	//Another recursive func (where base stays same, but split into two different equations)
	/*
	 * p(x, n) =	{1,							n = 0}
	 * 				{x * p(x, (n - 1)/ 2)^2,	n > 0 is odd}
	 * 				{p(x, n)^2,					n > 0 is even}
	 */
	public static double fasterRecPower(double x, int n) {		//Ask about this
		if(n == 0) {
			//Base case
			return 1;																		// 1 Operation
		}else if(n % 2 == 1){
			//Recursive case 1
			/**return x * fasterRecPower(x, (n - 1) / 2) * fasterRecPower(x, (n - 1) / 2);		// will have 2 recursive calls (increases the Time complexity & memory call stack)*/
			return x * Math.pow(fasterRecPower(x, (n - 1) / 2), 2);								//Will only have one recursive call be (n-1)/2 operations
		}else {
			//Recursive case 2
			//return fasterRecPower(x, n/2) * fasterRecPower(x, n/2);							// Operation will also be n/2 operations will be n = 2log(x) 
			return Math.pow(fasterRecPower(x, n/2), 2);											//Will be 1 recursive calls
		}
		//NOTE: in both recursive cases, it will be branching (split into two, therefore, it will be log) {log ==branching}
		/**
		 * When there is branching or division, then there is log (n/2)
		 * 		It is log because we start with one recursive call (will be 2 branches), then another
		 */
		
		//n = log(x)
		//Running time will be O(log(n))
	}
	
	//Binary Recursion: Severely dangerous!!
	/*
	 * Fibonacci numbers defined recursively:
	 * 		F_0 = 0
	 * 		F_1 = 1
	 * 		F_i = F_i-1 + F_i-2, for i > 1
	 * 
	 * 
	 * Golden Ration: F_i/F_i-1	==> [1 + sqrt(5)]/2 = 1.61803...
	 */
	public static int binaryFib(int k) {
		if(k < 2) {
			return k;
		}else {
			return binaryFib(k - 1) + binaryFib(k - 2);
		}
	}
	/**
	 * ******n_k is number of recursive calls  made by binaryFib(k), meaning that the + 1 is the base case
	 * 
	 * n_0 = 1
	 * n_1 = 1
	 * n_2 = n_1 + n_0 + 1 = 1 + 1 + 1 = 3				//These will calculate running time
	 * n_3 = n_2 + n_1 + 1 = 3 + 1 + 1 = 5
	 * n_4 = n_3 + n_2 + 1 = 5 + 3 + 1 = 9
	 * n_5 = n_5 + n_3 + 1 = 9 + 5 + 1 = 15
	 * 
	 * 
	 * Running time:	n_k > 2^(k/2) increases exponentially!
	 */
	//Make Fibonacci linear!
	/*
	 * Modify output as pair of Fib numbers (	F_k, F_(k-1)	)
	 */
	/**
	public static int[] linearFib(int k) {					//Fix This!!!
		int[] array2 = new int[2];
		if(k == 1) {
			array2 = new int[]{k, 0};
			return array2;
		}else {
			array2 = new int[]{i + j, 0};
			return array2;
		}
		
		//Running time will be O(k)
	}
	*/
	
	//Tower of Hanoi - 2 Disks
	/*
	 * 		The least amount of intermediate towers, the harder to solve
	 * 				|| 				||
	 * 				|| 				||
	 * 				|| 				||
	 * 			==========		==========
	 * 		The more, the easier to take each disk out
	 * Algorithm:
	 * 		MoveTower(disk, source, dest, spare){
	 * 			if(disk == 1){
	 * 				move disk from source to dest						//	1 operation
	 * 			}else{
	 * 				MoveTower(disk - 1, source, spare, dest)
	 * 				move disk from source to dest
	 * 				MoveTower(disk - 1, spare, dest, source)
	 * 			}
	 * 
	 * 			Running time:
	 * 				Assume running time is T(n); n is number of disks, recursive definition:
	 * 					T(n) = 1 + 2T(n - 1)
	 * 				then
	 * 					T(n) = 2T(n - 1) => 4T(n - 2) => 8T(n - 3) =>...=> 2^n
	 * 
	 * 				will be O(2^n) exponential
	 * 		}
	 */
	
	//Drawbacks and pitfalls of recursion
	
}
